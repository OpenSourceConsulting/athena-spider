/*
 * File: app/controller/GlobalController.js
 *
 * This file was generated by Sencha Architect version 3.0.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.2.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('spider.controller.GlobalController', {
    extend: 'Ext.app.Controller',

    init: function(application) {
        var global = this;

        var intervalId1, intervalId2, intervalId3, intervalId4;
        var chartDataStore = Ext.getStore('chartDataStore');
        var cpuChart = Ext.getCmp('cpuChart');
        var memoryChart = Ext.getCmp('memoryChart');
        var networkChart = Ext.getCmp('networkChart');

        //CROS 설정
        Ext.data.Connection.prototype.useDefaultXhrHeader = false;

        //Form Required 설정
        Ext.define('spider.form.field.Base', {

            override : 'Ext.form.field.Base',

            msgTarget: 'side',
            afterLabelTextTpl: [
                '<tpl if="allowBlank===false"><span style="color:red;font-weight:bold" data-qtip="Required">*</span></tpl>'
            ]

        });

        //Ajax Waiting Message 처리

        Ext.Ajax.on('beforerequest', function (conn, opts) {
            if(opts.waitMsg) {
                if(opts.waitMsgTarget) {
                    opts.waitMsgTarget.mask(opts.waitMsg, 'loading');
                } else {
                    Ext.getBody().mask(opts.waitMsg, 'loading');
                }

            }
        }, Ext.getBody());

        Ext.Ajax.on('requestcomplete', function (conn, resp, opts) {

            if(opts.waitMsg) {
                if(opts.waitMsgTarget) {
                    opts.waitMsgTarget.unmask();
                } else {
                    Ext.getBody().unmask();
                }
            }

        }, Ext.getBody());

        Ext.Ajax.on('requestexception', function (conn, resp, opts) {

            if(opts.waitMsg) {
                if(opts.waitMsgTarget) {
                    opts.waitMsgTarget.unmask();
                } else {
                    Ext.getBody().unmask();
                }
            }

        }, Ext.getBody());


        // Global variables를 정의하는 구문으로 GlobalData.urlPrefix, GlobalData.serverSize 등으로 어디에서든 접근이 가능하다.
        Ext.define('GLOBAL', {
            singleton: true,
            me: global,

            apiUrlPrefix : "http://192.168.0.130:5001/",
            graphiteUrlPrefix : "http://192.168.0.130:8000/"


        });

        /*
         * Global Validation(VTypes) Config
         */
        Ext.apply(Ext.form.field.VTypes, {
            daterange: function(val, field) {
                var date = field.parseDate(val);

                if (!date) {
                    return false;
                }
                if (field.startDateField && (!this.dateRangeMax || (date.getTime() != this.dateRangeMax.getTime()))) {
                    var start = field.up('form').down('#' + field.startDateField);
                    start.setMaxValue(date);
                    start.validate();
                    this.dateRangeMax = date;
                }
                else if (field.endDateField && (!this.dateRangeMin || (date.getTime() != this.dateRangeMin.getTime()))) {
                    var end = field.up('form').down('#' + field.endDateField);
                    end.setMinValue(date);
                    end.validate();
                    this.dateRangeMin = date;
                }
                /*
                 * Always return true since we're only using this vtype to set the
                 * min/max allowed values (these are tested for after the vtype test)
                 */
                return true;
            },

            daterangeText: 'Start date must be less than end date',

            password: function(val, field) {
                //var pwd = field.up('form').down('#passwd');
                pwd = field.previousNode('textfield');
                return (val == pwd.getValue());
            },

            passwordText: 'Passwords do not match',

            numeric: function(val, field) {
                var numericRe = /(^-?\d\d*\.\d*$)|(^-?\d\d*$)|(^-?\.\d\d*$)/;
                return numericRe.test(val);
            },
            numericText : 'Not a valid numeric number. Must be numbers',
            numericMask : /[.0-9]/

        });
        /**
         Chart legend multi Line
        */
        Ext.override(Ext.chart.Legend, {
            createItems: function() {
                var me = this,
                    chart = me.chart,
                    surface = chart.surface,
                    items = me.items,
                    padding = me.padding,
                    itemSpacing = me.itemSpacing,
                    spacingOffset = 2,
                    itemWidth = 0,
                    itemHeight = 0,
                    totalWidth = 0,
                    totalHeight = 0,
                    vertical = me.isVertical,
                    math = Math,
                    mfloor = math.floor,
                    mmax = math.max,
                    index = 0,
                    i = 0,
                    len = items ? items.length : 0,
                    x, y, item, bbox, height, width,
                    // chart dimensions
                    chartBBox = chart.chartBBox,
                    chartInsets = chart.insetPadding,
                    chartWidth = chartBBox.width - (chartInsets * 2),
                    chartHeight = chartBBox.height - (chartInsets * 2),
                    xOffset = 0,
                    yOffset = 0,
                    legendWidth = 0,
                    legendHeight = 0,
                    legendXOffset = 50,
                    legendYOffset = 50,
                    hSpacing, vSpacing;

                //remove all legend items
                if (len) {
                    for (; i < len; i++) {
                        items[i].destroy();
                    }
                }
                //empty array
                items.length = [];

                // Create all the item labels, collecting their dimensions and positioning each one
                // properly in relation to the previous item
                chart.series.each(function(series, i) {
                    if (series.showInLegend) {
                        Ext.each([].concat(series.yField), function(field, j) {
                            item = new Ext.chart.LegendItem({
                                legend: this,
                                series: series,
                                surface: chart.surface,
                                yFieldIndex: j
                            });
                            bbox = item.getBBox();

                            width = bbox.width;
                            height = bbox.height;

                            itemWidth = mmax(itemWidth, width);
                            itemHeight = mmax(itemHeight, height);

                            items.push(item);
                        }, this);

                    }
                }, me);

                //spacing = itemSpacing / (vertical ? 2 : 1);
                vSpacing = itemSpacing / 2;
                hSpacing = itemSpacing;
                if (vertical) {
                    if (chartHeight - legendYOffset < items.length * (itemHeight + vSpacing) + 2 * padding + vSpacing) {
                        legendHeight = chartHeight - legendYOffset;
                        yOffset = mfloor((legendHeight - mfloor((legendHeight - 2 * padding - vSpacing) / (itemHeight + vSpacing)) * (itemHeight + vSpacing)) / 2);
                    } else {
                        legendHeight = items.length * (itemHeight + vSpacing) + 2 * padding + vSpacing;
                        yOffset = vSpacing + padding;
                    }
                    xOffset = hSpacing + padding;
                    totalWidth = xOffset;
                    totalHeight = yOffset;
                } else {
                    if (chartWidth - legendXOffset < items.length * (itemWidth + hSpacing) + 2 * padding + hSpacing) {
                        legendWidth = chartWidth - legendXOffset;
                        xOffset = mfloor((legendWidth - mfloor((legendWidth - 2 * padding - hSpacing) / (itemWidth + hSpacing)) * (itemWidth + hSpacing)) / 2);
                    } else {
                        legendWidth = items.length * (itemWidth + hSpacing) + 2 * padding + hSpacing;
                        xOffset = padding + hSpacing;
                    }
                    yOffset = padding + vSpacing;
                    totalHeight = yOffset;
                    totalWidth = xOffset;
                }

                Ext.each(items, function(item, j) {
                    if (vertical && (totalHeight + vSpacing + itemHeight > chartHeight - legendYOffset)) {
                        totalHeight = yOffset;
                        totalWidth += itemWidth + hSpacing;
                    } else if (!vertical && (totalWidth + hSpacing + itemWidth > chartWidth - legendXOffset)) {
                        totalWidth = xOffset;
                        totalHeight += itemHeight + vSpacing;
                    }
                    item.x = totalWidth;
                    item.y = mfloor(totalHeight + itemHeight / 2);

                    // Collect cumulative dimensions
                    if (vertical)
                        totalHeight += itemHeight + vSpacing;
                    else
                        totalWidth += itemWidth + hSpacing;

                }, me);

                // Store the collected dimensions for later
                me.width = mfloor(vertical ? totalWidth + itemWidth + xOffset : legendWidth);
                me.height = mfloor(vertical ? legendHeight : totalHeight + itemHeight + yOffset);
                me.itemHeight = itemHeight;
                me.itemWidth = itemWidth;
            }

        });

        Ext.define('GlobalData', {
            singleton: true,

            intervalId1: intervalId1,
            intervalId2: intervalId2,
            intervalId3: intervalId3,
            intervalId4: intervalId4,
            chartDataStore: chartDataStore,
            cpuChart: cpuChart,
            memoryChart: memoryChart,
            networkChart: networkChart
        });
    },

    closeWindow: function(button, msg) {
        var closeMsg = "작업을 취소하시겠습니까?";
        if(msg) {
            closeMsg = msg;
        }

        Ext.MessageBox.confirm('Confirm', closeMsg, function(btn){

            if(btn == "yes"){
                button.up("window").close();
            }

        });

    }

});
